1. 클래스가 왜 필요할까? 계산기 예시를 통해 확인
2. 계산기는 이전 결괏값을 기억하고 있어야 됨

result = 0

**def add** (num):

**global** result
    result += num

**return** result

print(add(3))
print(add(4))

따라서 result를 글로벌(전역변수)로 선언해줌. 동시에 여러개의 계산을 하려면 저 함수를 여러개 만들어야 됨. 이런 걸 클래스로 간단하게 구현할 수 있음.

class cal:

def **_init**(self):

self.result = 0

def add(self, num):

self.result += num

return self.result

cal1 = cal()
cal2 = cal()

print(call.add(3))

print(call.add(4))

cal 클래스로 만든 별개의 객체 cal1, cal2는 각각 다른 역할을 수행한다. cal1, cal2의 결괏값 또한 독립적인 값을 유지한다. 객체만 생성하면 되기 때문의 각각의 연산을 하는 경우 객체를 더 생성하면 됨.

1. 만들어보자

**클래스 구상 먼저.**
a = fourcal() # a 객체 만들기
a.setdata(4, 2) # 4와 2를 a에 지정
print(a.add()) # 두수를 합한 결과 반환

**이 구상을 바탕으로 구조 만들기**

class fourcal:

pass

일단 아무기능도 하지 않는 pass로 만들어줌.

a = fourcal() # a 객체 먼저 만들고(타입도 확인)

a.setdata(4, 2) # 대상 4, 2를 지정

**매서드 만들기**

class fourcal:

 def setdata(self, first, second):

self.first = first

self.second = second

아까 거기 패스를 삭제하고 setback 함수 생성. 클래스 안 함수 == 매서드.

a = fourcal()
a. setdata(4, 2) # a객체를 통해 setback매서드 호출
여기서 setdata의 self 매개변수를 쓰지 않음? self에는 자동으로 매서드를 호출한 객체(a)가 전달됨. (위에 그림으로 이해)

- self 말고 다른 이름을 사용해도 됨.

어쨌든 저거는

self.first = 4
self.second = 2

라고 수행되고

a.first = 4
a.second = 2

와 같은 뜻이 됨.

**다음으로 기능 만들기**

위에서 두 개의 숫자값을 설정함.(setback) 이제 더하기 기능을 갖춘 메서드를 만들거임.

def add(self):

result = self.first + self.second

return result

실행

a = fourcal()
a.setdata(4, 2)
print(a.add())

여기서 a.add()는 add(self)매서드에 a객체를 입력시킴으로 a 값이 들어가서 6을 반환해줌.

# 생성자

setdata를 먼저 수행하지 않으면 add를 사용할 수 없음. setdata를 통해 a이 객체변수 first와 second가 생성되기 때문임.
객체의 초깃값을 설정할 필요가 있을 때는 setback 경우처럼 매서드를 통해 초깃값을 설정하기 보단 생성자를 구현하는 게 안전.
생성자: 객체가 생성될 때 자동으로 호출되는 메서드

파이썬은 메서드 이름으로 밑줄 이닛 밑줄을 사용함.

## 상속

어떤 클래스를 만들 때 다른 클래스의 기능을 물려받을 수 있게 만드는 개념.

예시 a^b 기능을 더한 클래스를 만들기

class morecal(fourcal):

pass

이런식으로 상속함.
class 클래스명(상속할 클래스 이름):

class morecal(fourcal):

def pow(self):

result = self.first ** self.second

return result

완성품

# 메서드 오버라이딩

나누기 0을 하는 경우의 오류를 수정

class safefourcal(fourcal):

def div(self):

if self.second == 0:

return 0

else:

return self.first/ self.second

여기서 만든 safefourcal클래스는 부모에 있는 메서드 div를 그대로 사용했음. 이런걸 '메서드 오버라이딩'이라고 함. 덮어쓰기.

클래스변수: 클래스에 선언한 변수(객체 변수랑 머가 다름?)

class f:

lastname = "김"

실행

print(f.lastname)

f클래스를 객체에 넣어서 객체로 이새끼(클래스변수) 사용할 수 있음. 단, 클래스f의 클래스변수를 수정하면 객체에서 사용할 때도 수정됨. 같은 주소를 공유함.

- 실무 프로그래밍을 할 때도 클래스 변수보단 객체 변수를 사용하는 경우가 많음.